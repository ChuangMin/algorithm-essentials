(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{154:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return d})),n.d(t,"default",(function(){return p}));var r=n(2),a=n(7),s=(n(0),n(303)),i=n(307),o=n(308),l={title:"Word Ladder"},c={unversionedId:"bfs/word-ladder",id:"bfs/word-ladder",isDocsHomePage:!1,title:"Word Ladder",description:"\u63cf\u8ff0",source:"@site/docs/bfs/word-ladder.md",slug:"/bfs/word-ladder",permalink:"/bfs/word-ladder",editUrl:"https://github.com/soulmachine/algorithm-essentials/edit/master/docs/bfs/word-ladder.md",version:"current",sidebar:"someSidebar",previous:{title:"\u7b80\u4ecb",permalink:"/bfs/README"},next:{title:"Word Ladder II",permalink:"/bfs/word-ladder-ii"}},d=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",children:[]},{value:"\u5206\u6790",id:"\u5206\u6790",children:[]},{value:"\u5355\u961f\u5217",id:"\u5355\u961f\u5217",children:[]},{value:"\u53cc\u961f\u5217",id:"\u53cc\u961f\u5217",children:[]},{value:"\u76f8\u5173\u9898\u76ee",id:"\u76f8\u5173\u9898\u76ee",children:[]}],u={rightToc:d};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(s.b)("wrapper",Object(r.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h3",{id:"\u63cf\u8ff0"},"\u63cf\u8ff0"),Object(s.b)("p",null,"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Only one letter can be changed at a time"),Object(s.b)("li",{parentName:"ul"},"Each intermediate word must exist in the dictionary")),Object(s.b)("p",null,"For example, Given:"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),'start = "hit"\nend = "cog"\ndict = ["hot","dot","dog","lot","log"]\n')),Object(s.b)("p",null,"As one shortest transformation is ",Object(s.b)("inlineCode",{parentName:"p"},'"hit" -> "hot" -> "dot" -> "dog" -> "cog"'),", return its length ",Object(s.b)("inlineCode",{parentName:"p"},"5"),"."),Object(s.b)("p",null,"Note:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Return 0 if there is no such transformation sequence."),Object(s.b)("li",{parentName:"ul"},"All words have the same length."),Object(s.b)("li",{parentName:"ul"},"All words contain only lowercase alphabetic characters.")),Object(s.b)("h3",{id:"\u5206\u6790"},"\u5206\u6790"),Object(s.b)("p",null,"\u6c42\u6700\u77ed\u8def\u5f84\uff0c\u7528\u5e7f\u641c\u3002"),Object(s.b)("h3",{id:"\u5355\u961f\u5217"},"\u5355\u961f\u5217"),Object(s.b)(i.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},Object(s.b)(o.a,{value:"java",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"// Word Ladder\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\n        Queue<State> q = new LinkedList<>();\n        HashSet<State> visited = new HashSet<>(); // \u5224\u91cd\n\n        final Function<State, Boolean> stateIsValid = (State s) ->\n                wordList.contains(s.word) || s.word.equals(endWord);\n        final Function<State, Boolean> stateIsTarget = (State s) ->\n                s.word.equals(endWord);\n\n        final Function<State, HashSet<State> > stateExtend = (State s) -> {\n            HashSet<State> result = new HashSet<>();\n\n            char[] array = s.word.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    State newState = new State(new String(array), s.level+1);\n\n                    if (stateIsValid.apply(newState) &&\n                            !visited.contains(newState)) {\n                        result.add(newState);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        State startState = new State(beginWord, 0);\n        q.offer(startState);\n        visited.add(startState);\n        while (!q.isEmpty()) {\n            State state = q.poll();\n\n            if (stateIsTarget.apply(state)) {\n                return state.level + 1;\n            }\n\n\n            HashSet<State> newStates = stateExtend.apply(state);\n            for (State newState : newStates) {\n                q.offer(newState);\n                visited.add(newState);\n            }\n        }\n        return 0;\n    }\n\n    static class State {\n        String word;\n        int level;\n\n        public State(String word, int level) {\n            this.word = word;\n            this.level = level;\n        }\n\n        @Override\n        public int hashCode() {\n            return word.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (this.hashCode() != other.hashCode()) return false;\n            if (!(other instanceof State)) return false;\n\n            return this.word.equals(((State) other).word);\n        }\n    }\n}\n"))),Object(s.b)(o.a,{value:"cpp",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"// Word Ladder\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nstruct state_t {\n    string word;\n    int level;\n\n    state_t() { word = \"\"; level = 0; }\n    state_t(const string& word, int level) {\n        this->word = word;\n        this->level = level;\n    }\n\n    bool operator==(const state_t &other) const {\n        return this->word == other.word;\n    }\n};\n\nnamespace std {\n    template<> struct hash<state_t> {\n    public:\n        size_t operator()(const state_t& s) const {\n            return str_hash(s.word);\n        }\n    private:\n        std::hash<std::string> str_hash;\n    };\n}\n\n\nclass Solution {\npublic:\n    int ladderLength(const string& start, const string &end,\n            const unordered_set<string> &dict) {\n        queue<state_t> q;\n        unordered_set<state_t> visited;  // \u5224\u91cd\n\n        auto state_is_valid = [&](const state_t& s) {\n            return dict.find(s.word) != dict.end() || s.word == end;\n        };\n        auto state_is_target = [&](const state_t &s) {return s.word == end; };\n        auto state_extend = [&](const state_t &s) {\n            unordered_set<state_t> result;\n\n            for (size_t i = 0; i < s.word.size(); ++i) {\n                state_t new_state(s.word, s.level + 1);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_state.word[i]) continue;\n\n                    swap(c, new_state.word[i]);\n\n                    if (state_is_valid(new_state) &&\n                        visited.find(new_state) == visited.end()) {\n                        result.insert(new_state);\n                    }\n                    swap(c, new_state.word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        state_t start_state(start, 0);\n        q.push(start_state);\n        visited.insert(start_state);\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            if (state_is_target(state)) {\n                return state.level + 1;\n            }\n\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                q.push(new_state);\n                visited.insert(new_state);\n            }\n        }\n        return 0;\n    }\n};\n")))),Object(s.b)("h3",{id:"\u53cc\u961f\u5217"},"\u53cc\u961f\u5217"),Object(s.b)(i.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},Object(s.b)(o.a,{value:"java",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"// Word Ladder\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\n        Queue<String> current = new LinkedList<>(); // \u5f53\u524d\u5c42\n        Queue<String> next = new LinkedList<>();    // \u4e0b\u4e00\u5c42\n        HashSet<String> visited = new HashSet<>();  // \u5224\u91cd\n\n        int level = -1;  // \u5c42\u6b21\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n\n                    if (stateIsValid.apply(newState) &&\n                            !visited.contains(newState)) {\n                        result.add(newState);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        current.offer(beginWord);\n        visited.add(beginWord);\n        while (!current.isEmpty()) {\n            ++level;\n            while (!current.isEmpty()) {\n                // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n                // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n                String state = current.poll();\n\n                if (stateIsTarget.apply(state)) {\n                    return level + 1;\n                }\n\n                HashSet<String> newStates = stateExtend.apply(state);\n                for (String newState : newStates) {\n                    next.offer(newState);\n                    visited.add(newState);\n                }\n            }\n            // swap\n            Queue<String> tmp = current;\n            current = next;\n            next = tmp;\n        }\n        return 0;\n    }\n}\n"))),Object(s.b)(o.a,{value:"cpp",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"// Word Ladder\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    int ladderLength(const string& start, const string &end,\n            const unordered_set<string> &dict) {\n        queue<string> current, next;    // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\n        unordered_set<string> visited;  // \u5224\u91cd\n\n        int level = -1;  // \u5c42\u6b21\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end;};\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_word(s);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if (state_is_valid(new_word) &&\n                        visited.find(new_word) == visited.end()) {\n                        result.insert(new_word);\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        current.push(start);\n        visited.insert(start);\n        while (!current.empty()) {\n            ++level;\n            while (!current.empty()) {\n                // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n                // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n                const auto state = current.front();\n                current.pop();\n\n                if (state_is_target(state)) {\n                    return level + 1;\n                }\n\n                const auto& new_states = state_extend(state);\n                for (const auto& new_state : new_states) {\n                    next.push(new_state);\n                    visited.insert(new_state);\n                }\n            }\n            swap(next, current);\n        }\n        return 0;\n    }\n};\n")))),Object(s.b)("h3",{id:"\u76f8\u5173\u9898\u76ee"},"\u76f8\u5173\u9898\u76ee"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(r.a)({parentName:"li"},{href:"/bfs/word-ladder-ii"}),"Word Ladder II"))))}p.isMDXComponent=!0},303:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return f}));var r=n(0),a=n.n(r);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),d=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),b=r,f=u["".concat(i,".").concat(b)]||u[b]||p[b]||s;return n?a.a.createElement(f,o(o({ref:t},c),{},{components:n})):a.a.createElement(f,o({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=b;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<s;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},304:function(e,t,n){"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n);else for(t in e)e[t]&&(a&&(a+=" "),a+=t);return a}t.a=function(){for(var e,t,n=0,a="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}},305:function(e,t,n){"use strict";var r=n(0);const a=Object(r.createContext)(void 0);t.a=a},306:function(e,t,n){"use strict";var r=n(0),a=n(305);t.a=function(){const e=Object(r.useContext)(a.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},307:function(e,t,n){"use strict";var r=n(0),a=n.n(r),s=n(306),i=n(304),o=n(49),l=n.n(o);const c=37,d=39;t.a=function(e){const{block:t,children:n,defaultValue:o,values:u,groupId:p}=e,{tabGroupChoices:b,setTabGroupChoices:f}=Object(s.a)(),[w,h]=Object(r.useState)(o),[v,g]=Object(r.useState)(!1);if(null!=p){const e=b[p];null!=e&&e!==w&&u.some((t=>t.value===e))&&h(e)}const m=e=>{h(e),null!=p&&f(p,e)},O=[],S=e=>{e.metaKey||e.altKey||e.ctrlKey||g(!0)},y=()=>{g(!1)};return Object(r.useEffect)((()=>{window.addEventListener("keydown",S),window.addEventListener("mousedown",y)}),[]),a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(i.a)("tabs",{"tabs--block":t})},u.map((({value:e,label:t})=>a.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":w===e,className:Object(i.a)("tabs__item",l.a.tabItem,{"tabs__item--active":w===e}),style:v?{}:{outline:"none"},key:e,ref:e=>O.push(e),onKeyDown:e=>{((e,t,n)=>{switch(n.keyCode){case d:((e,t)=>{const n=e.indexOf(t)+1;e[n]?e[n].focus():e[0].focus()})(e,t);break;case c:((e,t)=>{const n=e.indexOf(t)-1;e[n]?e[n].focus():e[e.length-1].focus()})(e,t)}})(O,e.target,e),S(e)},onFocus:()=>m(e),onClick:()=>{m(e),g(!1)},onPointerDown:()=>g(!1)},t)))),a.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},r.Children.toArray(n).filter((e=>e.props.value===w))[0]))}},308:function(e,t,n){"use strict";var r=n(0),a=n.n(r);t.a=function(e){return a.a.createElement("div",null,e.children)}}}]);