(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{119:function(t,n,e){"use strict";e.r(n),e.d(n,"frontMatter",(function(){return l})),e.d(n,"metadata",(function(){return d})),e.d(n,"rightToc",(function(){return c})),e.d(n,"default",(function(){return p}));var r=e(2),a=e(7),s=(e(0),e(337)),i=e(341),o=e(342),l={title:"Word Ladder II"},d={unversionedId:"bfs/word-ladder-ii",id:"bfs/word-ladder-ii",isDocsHomePage:!1,title:"Word Ladder II",description:"\u63cf\u8ff0",source:"@site/docs/bfs/word-ladder-ii.md",slug:"/bfs/word-ladder-ii",permalink:"/bfs/word-ladder-ii",editUrl:"https://github.com/soulmachine/algorithm-essentials/edit/master/docs/bfs/word-ladder-ii.md",version:"current",sidebar:"someSidebar",previous:{title:"Word Ladder",permalink:"/bfs/word-ladder"},next:{title:"Surrounded Regions",permalink:"/bfs/surrounded-regions"}},c=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",children:[]},{value:"\u5206\u6790",id:"\u5206\u6790",children:[]},{value:"\u5355\u961f\u5217",id:"\u5355\u961f\u5217",children:[]},{value:"\u53cc\u961f\u5217",id:"\u53cc\u961f\u5217",children:[]},{value:"\u56fe\u7684\u5e7f\u641c",id:"\u56fe\u7684\u5e7f\u641c",children:[]},{value:"\u76f8\u5173\u9898\u76ee",id:"\u76f8\u5173\u9898\u76ee",children:[]}],u={rightToc:c};function p(t){var n=t.components,e=Object(a.a)(t,["components"]);return Object(s.b)("wrapper",Object(r.a)({},u,e,{components:n,mdxType:"MDXLayout"}),Object(s.b)("h3",{id:"\u63cf\u8ff0"},"\u63cf\u8ff0"),Object(s.b)("p",null,"Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Only one letter can be changed at a time"),Object(s.b)("li",{parentName:"ul"},"Each intermediate word must exist in the dictionary")),Object(s.b)("p",null,"For example, Given:"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{}),'start = "hit"\nend = "cog"\ndict = ["hot","dot","dog","lot","log"]\n')),Object(s.b)("p",null,"Return"),Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),'[\n    ["hit","hot","dot","dog","cog"],\n    ["hit","hot","lot","log","cog"]\n]\n')),Object(s.b)("p",null,"Note:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"All words have the same length."),Object(s.b)("li",{parentName:"ul"},"All words contain only lowercase alphabetic characters.")),Object(s.b)("h3",{id:"\u5206\u6790"},"\u5206\u6790"),Object(s.b)("p",null,"\u8ddf Word Ladder \u6bd4\uff0c\u8fd9\u9898\u662f\u6c42\u8def\u5f84\u672c\u8eab\uff0c\u4e0d\u662f\u8def\u5f84\u957f\u5ea6\uff0c\u4e5f\u662f BFS\uff0c\u7565\u5fae\u9ebb\u70e6\u70b9\u3002"),Object(s.b)("p",null,"\u6c42\u4e00\u6761\u8def\u5f84\u548c\u6c42\u6240\u6709\u8def\u5f84\u6709\u5f88\u5927\u7684\u4e0d\u540c\uff0c\u6c42\u4e00\u6761\u8def\u5f84\uff0c\u6bcf\u4e2a\u72b6\u6001\u8282\u70b9\u53ea\u9700\u8981\u8bb0\u5f55\u4e00\u4e2a\u524d\u9a71\u5373\u53ef\uff1b\u6c42\u6240\u6709\u8def\u5f84\u65f6\uff0c\u6709\u7684\u72b6\u6001\u8282\u70b9\u53ef\u80fd\u6709\u591a\u4e2a\u7236\u8282\u70b9\uff0c\u5373\u8981\u8bb0\u5f55\u591a\u4e2a\u524d\u9a71\u3002"),Object(s.b)("p",null,"\u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\u3002"),Object(s.b)("h3",{id:"\u5355\u961f\u5217"},"\u5355\u961f\u5217"),Object(s.b)(i.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},Object(s.b)(o.a,{value:"java",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n                    final int newDepth = visited.get(s) + 1;\n\n                    if (stateIsValid.apply(newState)) {\n                        if (visited.containsKey(newState)) {\n                            final int depth = visited.get(newState);\n                            if (depth < newDepth) {\n                                // do nothing\n                            } else if (depth == newDepth) {\n                                result.add(newState);\n                            } else {\n                                throw new IllegalStateException(\"not possible to get here\");\n                            }\n\n                        } else {\n                            result.add(newState);\n                        }\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            HashSet<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"))),Object(s.b)(o.a,{value:"cpp",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n            const int new_depth = visited[s] + 1;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_state = s;\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_state[i]) continue;\n\n                    swap(c, new_state[i]);\n\n                    if (state_is_valid(new_state)) {\n                        auto visited_iter = visited.find(new_state);\n\n                        if (visited_iter != visited.end()) {\n                            const int depth = visited_iter->second;\n                            if (depth < new_depth) {\n                                // do nothing\n                            }\n                            else if (depth == new_depth) {\n                                result.insert(new_state);\n                            }\n                            else { // not possible\n                                throw std::logic_error(\"not possible to get here\");\n                            }\n                        }\n                        else {\n                            result.insert(new_state);\n                        }\n                    }\n                    swap(c, new_state[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n")))),Object(s.b)("h3",{id:"\u53cc\u961f\u5217"},"\u53cc\u961f\u5217"),Object(s.b)(i.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},Object(s.b)(o.a,{value:"java",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        HashSet<String> current = new HashSet<>();\n        HashSet<String> next = new HashSet<>();\n        HashSet<String> visited = new HashSet<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        int level = -1; // \u5c42\u6b21\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n\n                    if (stateIsValid.apply(newState) &&\n                            !visited.contains(newState)) {\n                        result.add(newState);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        current.add(beginWord);\n        while (!current.isEmpty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && level + 1 > result.get(0).size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (String state : current)\n                visited.add(state);\n\n            for (String state : current) {\n                if (stateIsTarget.apply(state)) {\n                    ArrayList<String> path = new ArrayList<>();\n                    genPath(father, beginWord, state, path, result);\n                    continue;\n                }\n                // \u6269\u5c55\u8282\u70b9\n                HashSet<String> newStates = stateExtend.apply(state);\n                for (String newState : newStates) {\n                    next.add(newState);\n                    ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                    parents.add(state);\n                    father.put(newState, parents);\n                }\n            }\n            current.clear();\n            // swap\n            HashSet<String> tmp = current;\n            current = next;\n            next = tmp;\n\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"))),Object(s.b)(o.a,{value:"cpp",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n            const string& end, const unordered_set<string> &dict) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        unordered_set<string> current, next;\n        unordered_set<string> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        int level = -1;  // \u5c42\u6b21\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end;};\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_word(s);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if (state_is_valid(new_word) &&\n                            visited.find(new_word) == visited.end()) {\n                        result.insert(new_word);\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string> > result;\n        current.insert(start);\n        while (!current.empty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\n            // \u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && level+1 > result[0].size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (const auto& state : current)\n                visited.insert(state);\n            for (const auto& state : current) {\n                if (state_is_target(state)) {\n                    vector<string> path;\n                    gen_path(father, path, start, state, result);\n                    continue;\n                }\n\n                const auto new_states = state_extend(state);\n                for (const auto& new_state : new_states) {\n                    next.insert(new_state);\n                    father[new_state].push_back(state);\n                }\n            }\n\n            current.clear();\n            swap(current, next);\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n            vector<string> &path, const string &start, const string &word,\n            vector<vector<string> > &result) {\n        path.push_back(word);\n        if (word == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                    result.push_back(path);\n                } else if(path.size() == result[0].size()) {\n                    result.push_back(path);\n                } else {\n                    // not possible\n                    throw std::logic_error(\"not possible to get here\");\n                }\n            } else {\n                result.push_back(path);\n            }\n            reverse(result.back().begin(), result.back().end());\n        } else {\n            for (const auto& f : father[word]) {\n                gen_path(father, path, start, f, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n")))),Object(s.b)("h3",{id:"\u56fe\u7684\u5e7f\u641c"},"\u56fe\u7684\u5e7f\u641c"),Object(s.b)("p",null,"\u524d\u9762\u7684\u89e3\u6cd5\uff0c\u5728\u72b6\u6001\u6269\u5c55\u7684\u65f6\u5019\uff0c\u6bcf\u6b21\u90fd\u662f\u4ece'a'\u5230'z'\u5168\u90e8\u679a\u4e3e\u4e00\u904d\uff0c\u91cd\u590d\u8ba1\u7b97\uff0c\u6bd4\u8f83\u6d6a\u8d39\uff0c\u5176\u5b9e\u5f53\u7ed9\u5b9a\u5b57\u5178",Object(s.b)("inlineCode",{parentName:"p"},"dict"),"\u540e\uff0c\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u7684\u8def\u5f84\u5c31\u56fa\u5b9a\u4e0b\u6765\u4e86\uff0c\u672c\u8d28\u4e0a\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u6784\u6210\u4e86\u4e00\u4e2a\u65e0\u5411\u56fe\u3002\u5982\u679c\u4e8b\u5148\u628a\u8fd9\u4e2a\u56fe\u6784\u5efa\u51fa\u6765\uff0c\u90a3\u4e48\u72b6\u6001\u6269\u5c55\u5c31\u4f1a\u5927\u5927\u52a0\u5feb\u3002"),Object(s.b)(i.a,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},Object(s.b)(o.a,{value:"java",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"import java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Function;\n\n// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        // only used by stateExtend()\n        final HashMap<String, HashSet<String>> g = buildGraph(wordList);\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, List<String> > stateExtend = (String s) -> {\n            List<String> result = new ArrayList<>();\n            final int newDepth = visited.get(s) + 1;\n            HashSet<String> list = g.get(s);\n            if (list == null) return result;\n\n            for (String newState : list) {\n                if (stateIsValid.apply(newState)) {\n                    if (visited.containsKey(newState)) {\n                        final int depth = visited.get(newState);\n                        if (depth < newDepth) {\n                            // do nothing\n                        } else if (depth == newDepth) {\n                            result.add(newState);\n                        } else {\n                            throw new IllegalStateException(\"not possible to get here\");\n                        }\n\n                    } else {\n                        result.add(newState);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            List<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n\n    private static HashMap<String, HashSet<String>> buildGraph(Set<String> dict) {\n        HashMap<String, HashSet<String>> adjacency_list = new HashMap<>();\n        for (String word: dict) {\n            char[] array = word.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newWord = new String(array);\n\n                    if (dict.contains(newWord)) {\n                        HashSet<String> list = adjacency_list.getOrDefault(\n                                word, new HashSet<>());\n                        list.add(newWord);\n                        adjacency_list.put(word, list);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n}\n"))),Object(s.b)(o.a,{value:"cpp",mdxType:"TabItem"},Object(s.b)("pre",null,Object(s.b)("code",Object(r.a)({parentName:"pre"},{className:"language-cpp"}),"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n        // only used by state_extend()\n        const unordered_map<string, unordered_set<string> >& g = build_graph(dict);\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            vector<string> result;\n            const int new_depth = visited[s] + 1;\n            auto iter = g.find(s);\n            if (iter == g.end()) return result;\n            const auto& list = iter->second;\n\n            for (const auto& new_state : list) {\n                if (state_is_valid(new_state)) {\n                    auto visited_iter = visited.find(new_state);\n                    if (visited_iter != visited.end()) {\n                        const int depth = visited_iter->second;\n                        if (depth < new_depth) {\n                            // do nothing\n                        }\n                        else if (depth == new_depth) {\n                            result.push_back(new_state);\n                        } else { // not possible\n                            throw std::logic_error(\"not possible to get here\");\n                        }\n                    }\n                    else {\n                        result.push_back(new_state);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n    unordered_map<string, unordered_set<string> > build_graph(\n        const unordered_set<string>& dict) {\n        unordered_map<string, unordered_set<string> > adjacency_list;\n\n        for (const auto& word : dict) {\n            for (size_t i = 0; i < word.size(); ++i) {\n                string new_word(word);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if ((dict.find(new_word) != dict.end())) {\n                        auto iter = adjacency_list.find(word);\n                        if (iter != adjacency_list.end()) {\n                            iter->second.insert(new_word);\n                        }\n                        else {\n                            adjacency_list.insert(pair<string,\n                                unordered_set<string >> (word, unordered_set<string>()));\n                            adjacency_list[word].insert(new_word);\n                        }\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n};\n")))),Object(s.b)("h3",{id:"\u76f8\u5173\u9898\u76ee"},"\u76f8\u5173\u9898\u76ee"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(r.a)({parentName:"li"},{href:"/bfs/word-ladder"}),"Word Ladder"))))}p.isMDXComponent=!0},337:function(t,n,e){"use strict";e.d(n,"a",(function(){return u})),e.d(n,"b",(function(){return f}));var r=e(0),a=e.n(r);function s(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){s(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function l(t,n){if(null==t)return{};var e,r,a=function(t,n){if(null==t)return{};var e,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)e=s[r],n.indexOf(e)>=0||(a[e]=t[e]);return a}(t,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(r=0;r<s.length;r++)e=s[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(a[e]=t[e])}return a}var d=a.a.createContext({}),c=function(t){var n=a.a.useContext(d),e=n;return t&&(e="function"==typeof t?t(n):o(o({},n),t)),e},u=function(t){var n=c(t.components);return a.a.createElement(d.Provider,{value:n},t.children)},p={inlineCode:"code",wrapper:function(t){var n=t.children;return a.a.createElement(a.a.Fragment,{},n)}},g=a.a.forwardRef((function(t,n){var e=t.components,r=t.mdxType,s=t.originalType,i=t.parentName,d=l(t,["components","mdxType","originalType","parentName"]),u=c(e),g=r,f=u["".concat(i,".").concat(g)]||u[g]||p[g]||s;return e?a.a.createElement(f,o(o({ref:n},d),{},{components:e})):a.a.createElement(f,o({ref:n},d))}));function f(t,n){var e=arguments,r=n&&n.mdxType;if("string"==typeof t||r){var s=e.length,i=new Array(s);i[0]=g;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var d=2;d<s;d++)i[d]=e[d];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,e)}g.displayName="MDXCreateElement"},338:function(t,n,e){"use strict";function r(t){var n,e,a="";if("string"==typeof t||"number"==typeof t)a+=t;else if("object"==typeof t)if(Array.isArray(t))for(n=0;n<t.length;n++)t[n]&&(e=r(t[n]))&&(a&&(a+=" "),a+=e);else for(n in t)t[n]&&(a&&(a+=" "),a+=n);return a}n.a=function(){for(var t,n,e=0,a="";e<arguments.length;)(t=arguments[e++])&&(n=r(t))&&(a&&(a+=" "),a+=n);return a}},339:function(t,n,e){"use strict";var r=e(0),a=e(340);n.a=function(){var t=Object(r.useContext)(a.a);if(null==t)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return t}},340:function(t,n,e){"use strict";var r=e(0),a=Object(r.createContext)(void 0);n.a=a},341:function(t,n,e){"use strict";var r=e(0),a=e.n(r),s=e(339),i=e(338),o=e(49),l=e.n(o),d=37,c=39;n.a=function(t){var n=t.block,e=t.children,o=t.defaultValue,u=t.values,p=t.groupId,g=t.className,f=Object(s.a)(),h=f.tabGroupChoices,b=f.setTabGroupChoices,w=Object(r.useState)(o),v=w[0],S=w[1],_=Object(r.useState)(!1),y=_[0],m=_[1];if(null!=p){var O=h[p];null!=O&&O!==v&&u.some((function(t){return t.value===O}))&&S(O)}var j=function(t){S(t),null!=p&&b(p,t)},L=[],x=function(t){t.metaKey||t.altKey||t.ctrlKey||m(!0)},z=function(){m(!1)};return Object(r.useEffect)((function(){return window.addEventListener("keydown",x),window.addEventListener("mousedown",z),function(){window.removeEventListener("keydown",x),window.removeEventListener("mousedown",z)}}),[]),a.a.createElement("div",null,a.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(i.a)("tabs",{"tabs--block":n},g)},u.map((function(t){var n=t.value,e=t.label;return a.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":v===n,className:Object(i.a)("tabs__item",l.a.tabItem,{"tabs__item--active":v===n}),style:y?{}:{outline:"none"},key:n,ref:function(t){return L.push(t)},onKeyDown:function(t){!function(t,n,e){switch(e.keyCode){case c:!function(t,n){var e=t.indexOf(n)+1;t[e]?t[e].focus():t[0].focus()}(t,n);break;case d:!function(t,n){var e=t.indexOf(n)-1;t[e]?t[e].focus():t[t.length-1].focus()}(t,n)}}(L,t.target,t),x(t)},onFocus:function(){return j(n)},onClick:function(){j(n),m(!1)},onPointerDown:function(){return m(!1)}},e)}))),a.a.createElement("div",{role:"tabpanel",className:"margin-vert--md"},r.Children.toArray(e).filter((function(t){return t.props.value===v}))[0]))}},342:function(t,n,e){"use strict";var r=e(0),a=e.n(r);n.a=function(t){return a.a.createElement("div",null,t.children)}}}]);